<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>My Project: BTreeIndex Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_b_tree_index-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BTreeIndex Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae737b5dea98c2e2036fd3b3d9bdcfc22"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree_index.html#ae737b5dea98c2e2036fd3b3d9bdcfc22">BTreeIndex</a> ()</td></tr>
<tr class="memdesc:ae737b5dea98c2e2036fd3b3d9bdcfc22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of <a class="el" href="class_b_tree_index.html">BTreeIndex</a> that sets up the initial variables It needs to compute number of total keys per level, given max keys per page.  <a href="#ae737b5dea98c2e2036fd3b3d9bdcfc22">More...</a><br /></td></tr>
<tr class="separator:ae737b5dea98c2e2036fd3b3d9bdcfc22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6202c61a8541b0f5c13eef1f1a940e31"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6202c61a8541b0f5c13eef1f1a940e31"></a>
vector&lt; <a class="el" href="class_data_entry.html">DataEntry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree_index.html#a6202c61a8541b0f5c13eef1f1a940e31">parse_idx_file</a> (string)</td></tr>
<tr class="memdesc:a6202c61a8541b0f5c13eef1f1a940e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">parser that expects a file with 3 tab-delimited columns with the following format: key where the middle value count is ignored <br /></td></tr>
<tr class="separator:a6202c61a8541b0f5c13eef1f1a940e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7270c48f911f355442265f1dc340fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a7270c48f911f355442265f1dc340fd"></a>
vector&lt; <a class="el" href="class_data_entry.html">DataEntry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree_index.html#a4a7270c48f911f355442265f1dc340fd">parse_idx_file_get_all</a> (string)</td></tr>
<tr class="memdesc:a4a7270c48f911f355442265f1dc340fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">parser that expects a file with 3 tab-delimited columns with the following format: key where the middle value count is ignored <br /></td></tr>
<tr class="separator:a4a7270c48f911f355442265f1dc340fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4517e016a4f60cd2e61471f6ba10f347"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree_index.html#a4517e016a4f60cd2e61471f6ba10f347">build_tree</a> (vector&lt; <a class="el" href="class_data_entry.html">DataEntry</a> &gt;)</td></tr>
<tr class="memdesc:a4517e016a4f60cd2e61471f6ba10f347"><td class="mdescLeft">&#160;</td><td class="mdescRight">builds a btree index using the bulkloading algorithm as discussed in the textbook  <a href="#a4517e016a4f60cd2e61471f6ba10f347">More...</a><br /></td></tr>
<tr class="separator:a4517e016a4f60cd2e61471f6ba10f347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46927719822348be775e2ce581a06de0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46927719822348be775e2ce581a06de0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree_index.html#a46927719822348be775e2ce581a06de0">setPageOffset</a> ()</td></tr>
<tr class="memdesc:a46927719822348be775e2ce581a06de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function when building btree index. Offsets range from 0 to total pages in the btree tree. This function sets each page's offset by doing a level-wise traversal (BFS) of the tree from left to right. root page has an offset of 0. Its leftmost child has an offset of 1. Its rightmost child has an offset of &lt;total pages in the child's level&gt; its leftmost grandchild's offset = its rightmost child's offset + 1 and so on.. <br /></td></tr>
<tr class="separator:a46927719822348be775e2ce581a06de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af931d39bed7e041211aafd30c6972152"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af931d39bed7e041211aafd30c6972152"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree_index.html#af931d39bed7e041211aafd30c6972152">BfsDebugPrint</a> ()</td></tr>
<tr class="memdesc:af931d39bed7e041211aafd30c6972152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints each page in the tree. <br /></td></tr>
<tr class="separator:af931d39bed7e041211aafd30c6972152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e5ad19a5ccc848bf9a80480e1a0ec3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37e5ad19a5ccc848bf9a80480e1a0ec3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree_index.html#a37e5ad19a5ccc848bf9a80480e1a0ec3">addNodeToTree</a> (int, <a class="el" href="class_b_tree_page.html">BTreePage</a> *)</td></tr>
<tr class="memdesc:a37e5ad19a5ccc848bf9a80480e1a0ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function for building a btree index. It adds a node to a level <br /></td></tr>
<tr class="separator:a37e5ad19a5ccc848bf9a80480e1a0ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f08960f28fbaee925bd76a225110f56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree_index.html#a5f08960f28fbaee925bd76a225110f56">flush</a> (string)</td></tr>
<tr class="memdesc:a5f08960f28fbaee925bd76a225110f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">writes the btree index to a binary file via a level-wise traversal (BFS) Format of the index file: number of pages in the index (8 bytes) followed by root page, leftmost child page of root, ...., rightmost child page of root, leftmost grandchild of root, ..., leftmost leaf page, ..., rightmost leaf page.  <a href="#a5f08960f28fbaee925bd76a225110f56">More...</a><br /></td></tr>
<tr class="separator:a5f08960f28fbaee925bd76a225110f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b32e1e49d409365bffaf2f111068f23"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b32e1e49d409365bffaf2f111068f23"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>probe</b> (uint64_t key, vector&lt; <a class="el" href="class_b_tree_page.html">BTreePage</a> * &gt; stream)</td></tr>
<tr class="separator:a3b32e1e49d409365bffaf2f111068f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768090c78f62663632baa93b3786552f"><td class="memItemLeft" align="right" valign="top">pair&lt; bool, uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree_index.html#a768090c78f62663632baa93b3786552f">probe</a> (uint64_t, FILE *)</td></tr>
<tr class="memdesc:a768090c78f62663632baa93b3786552f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is not being used in the current implementation of probe. btree quality probe on a single key using file handler. First, it traverses the btree index, then it calls probe_bin to probe the binary data file, looking for the offset of the key.  <a href="#a768090c78f62663632baa93b3786552f">More...</a><br /></td></tr>
<tr class="separator:a768090c78f62663632baa93b3786552f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7c70180b49b73c02352ba1135a91f7"><td class="memItemLeft" align="right" valign="top">pair&lt; bool, uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree_index.html#a5f7c70180b49b73c02352ba1135a91f7">probe</a> (uint64_t, int, int)</td></tr>
<tr class="memdesc:a5f7c70180b49b73c02352ba1135a91f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">btree quality probe on a single key using file descriptor. First, it traverses the btree index, then it calls probe_bin to probe the binary data file, looking for the offset of the key.  <a href="#a5f7c70180b49b73c02352ba1135a91f7">More...</a><br /></td></tr>
<tr class="separator:a5f7c70180b49b73c02352ba1135a91f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5d7a705ae4eb777695d819b88c08a4"><td class="memItemLeft" align="right" valign="top">pair&lt; bool, uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree_index.html#a8a5d7a705ae4eb777695d819b88c08a4">probe_bin</a> (uint64_t, int, off_t)</td></tr>
<tr class="memdesc:a8a5d7a705ae4eb777695d819b88c08a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function for btree quality probe on a single key. It searches the binary data file, looking for key and if key is found, returns an offset to the binary data file. If key is not found, return an offset of the smallest key larger than the search key.  <a href="#a8a5d7a705ae4eb777695d819b88c08a4">More...</a><br /></td></tr>
<tr class="separator:a8a5d7a705ae4eb777695d819b88c08a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212f6138db459618a7dd7e2ccc813cc3"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; uint64_t, uint64_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree_index.html#a212f6138db459618a7dd7e2ccc813cc3">range_probe_gt</a> (uint64_t, int, int, off_t)</td></tr>
<tr class="memdesc:a212f6138db459618a7dd7e2ccc813cc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">range probe if we are searching for all keys x such that: x &gt;= key  <a href="#a212f6138db459618a7dd7e2ccc813cc3">More...</a><br /></td></tr>
<tr class="separator:a212f6138db459618a7dd7e2ccc813cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648938da25539265a0c938e989076e06"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; uint64_t, uint64_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree_index.html#a648938da25539265a0c938e989076e06">range_probe_lt</a> (uint64_t, int, int)</td></tr>
<tr class="memdesc:a648938da25539265a0c938e989076e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">range probe if we are searching for all keys x such that: key &gt;= x  <a href="#a648938da25539265a0c938e989076e06">More...</a><br /></td></tr>
<tr class="separator:a648938da25539265a0c938e989076e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5cdb0e95eb8472762f945ccb7ade6d"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; uint64_t, uint64_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree_index.html#acf5cdb0e95eb8472762f945ccb7ade6d">range_probe_endpts</a> (uint64_t, uint64_t, int, int, off_t)</td></tr>
<tr class="memdesc:acf5cdb0e95eb8472762f945ccb7ade6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">range probe if we are searching for all keys x such that: start_key &lt;= x &lt;= end_key  <a href="#acf5cdb0e95eb8472762f945ccb7ade6d">More...</a><br /></td></tr>
<tr class="separator:acf5cdb0e95eb8472762f945ccb7ade6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60cebd82ad0c571732099c1d67dd2c2a"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; uint64_t, uint64_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree_index.html#a60cebd82ad0c571732099c1d67dd2c2a">range_probe_bin</a> (int, off_t, off_t)</td></tr>
<tr class="memdesc:a60cebd82ad0c571732099c1d67dd2c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function for range probe. Given a start offset and an end offset of a binary data file, return all keys within the offsets  <a href="#a60cebd82ad0c571732099c1d67dd2c2a">More...</a><br /></td></tr>
<tr class="separator:a60cebd82ad0c571732099c1d67dd2c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a988b1687e253f7899d8d0a9e9843b006"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a988b1687e253f7899d8d0a9e9843b006"></a>
<a class="el" href="class_b_tree_page.html">BTreePage</a>&#160;</td><td class="memItemRight" valign="bottom"><b>root</b></td></tr>
<tr class="separator:a988b1687e253f7899d8d0a9e9843b006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4ae24282d1758307060525cba080c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd4ae24282d1758307060525cba080c7"></a>
vector&lt; vector&lt; <a class="el" href="class_b_tree_page.html">BTreePage</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>tree</b></td></tr>
<tr class="separator:abd4ae24282d1758307060525cba080c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7982147961269188e41438a5682b14f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7982147961269188e41438a5682b14f7"></a>
vector&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keys_per_level</b></td></tr>
<tr class="separator:a7982147961269188e41438a5682b14f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a1ab8990dd4e454d83e81acc3adbd4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87a1ab8990dd4e454d83e81acc3adbd4"></a>
vector&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>fanout_per_level</b></td></tr>
<tr class="separator:a87a1ab8990dd4e454d83e81acc3adbd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9453917f1f749a4ba4b74e0821c670c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9453917f1f749a4ba4b74e0821c670c"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>max_level</b> = 20</td></tr>
<tr class="separator:ae9453917f1f749a4ba4b74e0821c670c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae737b5dea98c2e2036fd3b3d9bdcfc22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BTreeIndex::BTreeIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor of <a class="el" href="class_b_tree_index.html">BTreeIndex</a> that sets up the initial variables It needs to compute number of total keys per level, given max keys per page. </p>
<p>Constructor of <a class="el" href="class_b_tree_index.html">BTreeIndex</a> that sets up the initial variables </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4517e016a4f60cd2e61471f6ba10f347"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BTreeIndex::build_tree </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="class_data_entry.html">DataEntry</a> &gt;&#160;</td>
          <td class="paramname"><em>entries</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>builds a btree index using the bulkloading algorithm as discussed in the textbook </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entries</td><td>all (key,rid) entries </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5f08960f28fbaee925bd76a225110f56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BTreeIndex::flush </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>indexFilePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>writes the btree index to a binary file via a level-wise traversal (BFS) Format of the index file: number of pages in the index (8 bytes) followed by root page, leftmost child page of root, ...., rightmost child page of root, leftmost grandchild of root, ..., leftmost leaf page, ..., rightmost leaf page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexFilePath</td><td>path of the output index file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a768090c78f62663632baa93b3786552f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; bool, uint64_t &gt; BTreeIndex::probe </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>indexFile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is not being used in the current implementation of probe. btree quality probe on a single key using file handler. First, it traverses the btree index, then it calls probe_bin to probe the binary data file, looking for the offset of the key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key we are probing for </td></tr>
    <tr><td class="paramname">indexFile</td><td>file handler of the btree index file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5f7c70180b49b73c02352ba1135a91f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; bool, uint64_t &gt; BTreeIndex::probe </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indexFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>binFile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>btree quality probe on a single key using file descriptor. First, it traverses the btree index, then it calls probe_bin to probe the binary data file, looking for the offset of the key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key we are probing for </td></tr>
    <tr><td class="paramname">indexFile</td><td>file descriptor of the btree index file </td></tr>
    <tr><td class="paramname">binFile</td><td>file descriptor of the binary data file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8a5d7a705ae4eb777695d819b88c08a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; bool, uint64_t &gt; BTreeIndex::probe_bin </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indexFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>helper function for btree quality probe on a single key. It searches the binary data file, looking for key and if key is found, returns an offset to the binary data file. If key is not found, return an offset of the smallest key larger than the search key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key we are probing for </td></tr>
    <tr><td class="paramname">indexFile</td><td>file descriptor of the binary data file </td></tr>
    <tr><td class="paramname">offset</td><td>start offset of the binary data file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a60cebd82ad0c571732099c1d67dd2c2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; uint64_t, uint64_t &gt; &gt; BTreeIndex::range_probe_bin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indexFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t&#160;</td>
          <td class="paramname"><em>end_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>helper function for range probe. Given a start offset and an end offset of a binary data file, return all keys within the offsets </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexFile</td><td>file descriptor of the binary data file </td></tr>
    <tr><td class="paramname">offset</td><td>start offset of the binary data file </td></tr>
    <tr><td class="paramname">end_offset</td><td>end offset of the binary data file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf5cdb0e95eb8472762f945ccb7ade6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; uint64_t, uint64_t &gt; &gt; BTreeIndex::range_probe_endpts </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>start_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>end_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indexFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dataBinFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t&#160;</td>
          <td class="paramname"><em>bin_file_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>range probe if we are searching for all keys x such that: start_key &lt;= x &lt;= end_key </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_key</td><td>value of key for the inquality start_key &lt;= x &lt;= end_key </td></tr>
    <tr><td class="paramname">end_key</td><td>value of key for the inquality start_key &lt;= x &lt;= end_key </td></tr>
    <tr><td class="paramname">indexFile</td><td>file descriptor of the binary index file </td></tr>
    <tr><td class="paramname">dataBinFile</td><td>file descriptor of the binary data file </td></tr>
    <tr><td class="paramname">bin_file_end</td><td>size of dataBinFile (i.e. last byte of dataBinFile) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a212f6138db459618a7dd7e2ccc813cc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; uint64_t, uint64_t &gt; &gt; BTreeIndex::range_probe_gt </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indexFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dataBinFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t&#160;</td>
          <td class="paramname"><em>bin_file_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>range probe if we are searching for all keys x such that: x &gt;= key </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>value of key for the inquality x &gt;= key </td></tr>
    <tr><td class="paramname">indexFile</td><td>file descriptor of the binary index file </td></tr>
    <tr><td class="paramname">dataBinFile</td><td>file descriptor of the binary data file </td></tr>
    <tr><td class="paramname">bin_file_end</td><td>size of dataBinFile (i.e. last byte of dataBinFile) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a648938da25539265a0c938e989076e06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; uint64_t, uint64_t &gt; &gt; BTreeIndex::range_probe_lt </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indexFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dataBinFile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>range probe if we are searching for all keys x such that: key &gt;= x </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>value of key for the inquality key &gt;= x </td></tr>
    <tr><td class="paramname">indexFile</td><td>file descriptor of the binary index file </td></tr>
    <tr><td class="paramname">dataBinFile</td><td>file descriptor of the binary data file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_b_tree_index_8h_source.html">BTreeIndex.h</a></li>
<li><a class="el" href="_b_tree_index_8cpp.html">BTreeIndex.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu May 4 2017 22:36:36 for My Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
